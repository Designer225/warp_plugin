
namespace = warp_plugin

# called on start and single player save load
# if added after multiplayer start, blame the host for indecision
event = {
	id = warp_plugin.0
	hide_window = yes
	is_triggered_only = yes
	fire_only_once = yes

	immediate = {
		set_global_flag = warp_plugin_installed
		every_country = {
			if = {
				limit = {
					owner_main_species = {
						has_trait = trait_warp_ftl_theory
					}
				}
				add_modifier = {
					modifier = warp_plugin_warp_ftl_theory
				}
			}
		}
	}
}

# called on game start
country_event = {
	id = warp_plugin.1
	title = warp_plugin.1.name
	picture = GFX_evt_ship_travel
	show_sound = event_ship_thrusters
	is_triggered_only = yes
	fire_only_once = yes
	
	desc = {
		trigger = {
			country_prefers_warp_drives = yes
		}
		text = warp_plugin.1.desc
	}

	desc = {
		trigger = {
			country_prefers_warp_drives = no
		}
		text = warp_plugin.1.desc.hyper
	}
	
	option = {
		name = ACKNOWLEDGED
	}
}

# triggers on every tick, but requires a warp drive and a jump order to execute
fleet_event = {
	id = warp_plugin.100
	hide_window = yes
	# is_triggered_only = yes
	mean_time_to_happen = { days = 1 }

	trigger = {
		not = { has_fleet_flag = warp_plugin_active }
		has_fleet_order = jumpdrive_order
		fleet_has_warp_drive = yes
	}

	immediate = {
		# Sets flag for current fleet. This will be retrieved upon jump.
		# Set to 2 days in case the fleet jumped and we need to retrieve the source location.
		set_timed_fleet_flag = {
			flag = warp_plugin_fleet_location_@solar_system
			days = 2
		}
	}
}

# called when ship with prototype drive jumps
ship_event = {
	id = warp_plugin.102
	hide_window = yes
	is_triggered_only = yes

	trigger = {
		fleet = {
			not = { has_fleet_flag = warp_plugin_active }
			fleet_has_warp_drive = yes
		}
	}

	immediate = {
		fleet = {
			# Save destination scope.
			solar_system = {
				save_event_target_as = warp_plugin_fleet_destination
			}
			# Remove the warp_plugin_fleet_location_@solar_system if it's set for this system.
			# We need the other one; there's a reason the flag was set for 2 days.
			if = {
				limit = {
					has_fleet_flag = warp_plugin_fleet_location_@solar_system
				}
				remove_fleet_flag = warp_plugin_fleet_location_@solar_system
			}
			# Now save the source scope.
			random_system = {
				limit = {
					root.fleet = {
						has_fleet_flag = warp_plugin_fleet_location_@prev
					}
				}
				save_event_target_as = warp_plugin_fleet_source
			}
			# get distance from jump source to jump destination
			export_trigger_value_to_variable = {
				trigger = distance
				variable = warp_distance_total
				parameters = {
					source = event_target:warp_plugin_fleet_source
					type = euclidean
				}
			}
			fleet_get_warp_speed_mult = yes # get fleet min warp speed
			set_variable = {
				which = warp_time_remaining
				value = value:warp_travel_time
			}
			clear_variable = warp_distance_total
			clear_variable = warp_speed_mult
			owner = {
				start_situation = {
					type = situation_warp_in_progress
					target = prev
				}
				random_situation = {
					limit = {
						is_situation_type = situation_warp_in_progress
						target = {
							is_same_value = root.fleet
						}
					}
					save_event_target_as = warp_situation
				}
			}
			fleet_event = { id = warp_plugin.110 }
		}
	}
}

# pulse event for when ship has jumped
fleet_event = {
	id = warp_plugin.110
	is_triggered_only = yes
	hide_window = yes

	trigger = {
		exists = this
	}

	immediate = {
		set_timed_fleet_flag = {
			flag = warp_plugin_active
			days = 2
		}
		if = {
			limit = {
				not = { exists = event_target:warp_situation }
			}
			owner = {
				random_situation = {
					limit = {
						is_situation_type = situation_warp_in_progress
						target = {
							is_same_value = root
						}
					}
					save_event_target_as = warp_situation
				}
			}
			# save_event_target_as = warp_target_system # used for MIA
		}
		if = { # mia check
			limit = {
				OR = {
					not = { exists = solar_system }
					not = { can_access_system = event_target:warp_plugin_fleet_destination }
				}
			}
			clear_variable = warp_time_remaining
			set_event_locked = no
			remove_modifier = warp_plugin_warp_in_progress
			abort_situation = event_target:warp_situation
			create_message = {
				type = MESSAGE_TYPE_ESN_ABORTED
				localization = MESSAGE_ESN_ABORTED
				days = 30
				target = this
				variable = {
					type = name
					localization = FLEET_NAME
					scope = this
				}
				variable = {
					type = name
					localization = SYSTEM
					scope = event_target:warp_plugin_fleet_destination
				}
			}
			remove_fleet_flag = warp_plugin_active
			set_mia = mia_return_home
			set_mia_return_delay = @mia_time
		}
		else_if = { # duration check
			limit = {
				check_variable = {
					which = warp_time_remaining
					value > 0
				}
			}
			subtract_variable = {
				which = warp_time_remaining
				value = 1
			}
			event_target:warp_situation = {
				add_situation_progress = progress_rate
			}
			warp_plugin_failure_roll = yes
			fleet_event = { id = warp_plugin.110 days = 1 }
		}
		else = { # on warp end
			clear_variable = warp_time_remaining
			# remove_modifier = warp_plugin_warp_in_progress
			remove_modifier = warp_plugin_warp_in_progress
			abort_situation = event_target:warp_situation
			create_message = {
				type = MESSAGE_TYPE_ESN_ARRIVED
				localization = MESSAGE_ESN_ARRIVED
				days = 30
				target = this
				variable = {
					type = name
					localization = FLEET_NAME
					scope = this
				}
				variable = {
					type = name
					localization = SYSTEM
					scope = solar_system
				}
			}
			remove_fleet_flag = warp_plugin_active
			set_location = {
				target = event_target:warp_plugin_fleet_destination
				distance = @warp_entry_distance
				angle = random
				direction = in_system
			}
			set_event_locked = no
		}
	}
}

## Situation: Warp in Progress
# on abort - failures
fleet_event = {
	id = warp_plugin.120
	title = warp_plugin.120.name
	desc = warp_plugin.120.desc
	picture = GFX_evt_ship_travel
	show_sound = event_ship_thrusters
	is_triggered_only = yes

	trigger = {
		fleet_has_warp_failure = yes
	}

	option = {
		name = UNFORTUNATE
		if = {
			limit = {
				has_fleet_flag = warp_plugin_weapon_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_weapon_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_propulsion_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_propulsion_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_shield_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_shield_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_armor_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_armor_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_cloak_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_cloak_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_sensor_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_sensor_failure
					months = 1
				}
			}
		}
		hidden_effect = {
			if = {
				limit = { has_fleet_flag = warp_plugin_weapon_failure }
				remove_fleet_flag = warp_plugin_weapon_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_propulsion_failure }
				remove_fleet_flag = warp_plugin_propulsion_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_shield_failure }
				remove_fleet_flag = warp_plugin_shield_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_armor_failure }
				remove_fleet_flag = warp_plugin_armor_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_cloak_failure }
				remove_fleet_flag = warp_plugin_cloak_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_sensor_failure }
				remove_fleet_flag = warp_plugin_sensor_failure
			}
		}
	}
}

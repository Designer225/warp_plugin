
namespace = warp_plugin

# called on start and single player save load
# if added after multiplayer start, blame the host for indecision
event = {
	id = warp_plugin.0
	hide_window = yes
	is_triggered_only = yes
	fire_only_once = yes

	immediate = {
		set_global_flag = warp_plugin_installed
		every_country = {
			if = {
				limit = {
					owner_main_species = {
						has_trait = trait_warp_ftl_theory
					}
				}
				add_modifier = {
					modifier = warp_plugin_warp_ftl_theory
				}
			}
		}
	}
}

# called on game start
country_event = {
	id = warp_plugin.1
	title = warp_plugin.1.name
	picture = GFX_evt_ship_travel
	show_sound = event_ship_thrusters
	is_triggered_only = yes
	fire_only_once = yes
	
	desc = {
		trigger = {
			country_prefers_warp_drives = yes
		}
		text = warp_plugin.1.desc
	}

	desc = {
		trigger = {
			country_prefers_warp_drives = no
		}
		text = warp_plugin.1.desc.hyper
	}
	
	option = {
		name = ACKNOWLEDGED
	}
}

# triggers on every tick
fleet_event = {
	id = warp_plugin.100
	hide_window = yes
	mean_time_to_happen = { days = 1 }

	trigger = {
		fleet_has_warp_drive = yes
	}

	immediate = {
		if = {
			limit = {
				has_fleet_flag = warp_plugin_active
			}
			fleet_event = {
				id = warp_plugin.110
			}
		}
		else_if = {
			limit = {
				exists = solar_system
			}
			# Sets flag for current fleet. This will be retrieved upon jump.
			# Set to 2 days in case the fleet jumped and we need to retrieve the source location.
			set_timed_fleet_flag = {
				flag = warp_plugin_fleet_location_@solar_system
				days = 2
			}
		}
		else_if = {
			limit = {
				not = { has_fleet_flag = warp_plugin_mia_in_progress }
			}
			fleet_event = {
				id = warp_plugin.111
			}
		}
	}
}

# called when ship with prototype drive jumps
ship_event = {
	id = warp_plugin.102
	hide_window = yes
	is_triggered_only = yes

	trigger = {
		fleet = {
			not = { has_fleet_flag = warp_plugin_active }
			fleet_has_warp_drive = yes
		}
	}

	immediate = {
		fleet = {
			# Save destination scope.
			solar_system = {
				save_event_target_as = warp_plugin_warp_destination
			}
			# Remove the warp_plugin_fleet_location_@solar_system if it's set for this system.
			# We need the other one; there's a reason the flag was set for 2 days.
			if = {
				limit = {
					has_fleet_flag = warp_plugin_fleet_location_@solar_system
				}
				remove_fleet_flag = warp_plugin_fleet_location_@solar_system
			}
			# Now save the source scope.
			random_system = {
				limit = {
					root.fleet = {
						has_fleet_flag = warp_plugin_fleet_location_@prev
					}
				}
				save_event_target_as = warp_plugin_warp_source
			}
			# set flags for both source and destination
			set_fleet_flag = warp_plugin_warp_source_@event_target:warp_plugin_warp_source
			set_fleet_flag = warp_plugin_warp_destination_@event_target:warp_plugin_warp_destination
			# get distance from jump source to jump destination
			export_trigger_value_to_variable = {
				trigger = distance
				variable = warp_distance_total
				parameters = {
					source = event_target:warp_plugin_warp_source
					type = euclidean
				}
			}
			fleet_get_warp_speed_mult = {
				FLEET = this
				OUTPUT = warp_speed_mult
			}
			set_variable = {
				which = warp_time_remaining
				value = value:warp_travel_time|DISTANCE|warp_distance_total|SPEED|warp_speed_mult|
			}
			set_variable = {
				which = warp_time_total
				value = warp_time_remaining
			}
			clear_variable = warp_distance_total
			clear_variable = warp_speed_mult
			# start situation
			owner = {
				start_situation = {
					type = situation_warp_in_progress
					target = prev
				}
				random_situation = {
					limit = {
						is_situation_type = situation_warp_in_progress
						target = {
							is_same_value = root.fleet
						}
					}
					save_event_target_as = warp_situation
				}
			}
			# final setup, set relevant flags and modifiers
			set_event_locked = yes
			add_modifier = {
				modifier = warp_plugin_warp_in_progress
			}
			set_fleet_flag = warp_plugin_active
			set_saved_date = {
				key = warp_plugin_arrival_date
				days_from_present = warp_time_remaining
				expires = warp_time_remaining
			}
		}
	}
}

# pulse event for when ship is warping (called from warp_plugin.100)
fleet_event = {
	id = warp_plugin.110
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		# get scopes
		warp_plugin_wip_retrieve_scopes = {
			FLEET = this
			SITUATION_OUT = warp_situation
			SOURCE_OUT = warp_plugin_warp_source
			DESTINATION_OUT = warp_plugin_warp_destination
		}

		# tick down
		subtract_variable = {
			which = warp_time_remaining
			value = 1
		}

		if = {
			limit = { # mia check
				OR = {
					not = { exists = solar_system }
					not = { can_access_system = event_target:warp_plugin_warp_destination }
				}
			}
			# force situation approach to correctly update... maybe
			event_target:warp_situation = {
				set_situation_approach = approach_normal_operations
			}
			# send fleet to mia and notify owner
			set_variable = {
				which = warp_time_remaining
				value = value:warp_mia_return_time|TOTAL|warp_time_total|REMAINING|warp_time_remaining|
			}
			set_saved_date = {
				key = warp_plugin_arrival_date
				days_from_present = warp_time_remaining
				expires = warp_time_remaining
			}
			create_message = {
				type = MESSAGE_TYPE_WARP_ABORTED
				localization = MESSAGE_WARP_ABORTED
				days = 30
				target = this
				variable = {
					type = name
					localization = FLEET_NAME
					scope = this
				}
				variable = {
					type = name
					localization = SYSTEM
					scope = event_target:warp_plugin_warp_destination
				}
				variable = {
					type = variable
					varname = warp_time_remaining
					localization = DAYS
					scope = this
				}
			}
			# make mia
			warp_plugin_initiate_return_mia = {
				TIMER_VAR = warp_time_remaining
			}
			# add additional day to allow mia to resolve
			change_variable = {
				which = warp_time_remaining
				value = 2
			}
			# set timed flag to block new mia
			set_timed_fleet_flag = {
				flag = warp_plugin_mia_in_progress
				days = warp_time_remaining
			}
			# common cleanup
			warp_plugin_warp_end_cleanup = {
				FLEET = this
			}
		}
		else_if = { # warp complete
			limit = {
				check_variable = {
					which = warp_time_remaining
					value = 0
				}
			}
			# randomize fleet location in system and notify owner of arrival
			create_message = {
				type = MESSAGE_TYPE_WARP_ARRIVED
				localization = MESSAGE_WARP_ARRIVED
				days = 30
				target = this
				variable = {
					type = name
					localization = FLEET_NAME
					scope = this
				}
				variable = {
					type = name
					localization = SYSTEM
					scope = solar_system
				}
			}
			set_location = {
				target = event_target:warp_plugin_warp_destination
				distance = @warp_entry_distance
				angle = random
				direction = in_system
			}
			# common cleanup
			warp_plugin_warp_end_cleanup = {
				FLEET = this
			}
		}
		else = { # update situation
			event_target:warp_situation = {
				add_situation_progress = progress_rate
			}
			warp_plugin_failure_roll = {
				FLEET = this
			}
		}
	}
}

fleet_event = {
	id = warp_plugin.111
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		# get home base, using capital as fallback
		if = {
			limit = {
				exists = root.starbase
			}
			root.starbase.fleet.solar_system = {
				save_event_target_as = warp_plugin_home_base
			}
		}
		else = {
			root.owner.capital_scope.solar_system = {
				save_event_target_as = warp_plugin_home_base
			}
		}
		# find previous location and compute distance
		random_system = {
			limit = {
				root = { has_fleet_flag = warp_plugin_fleet_location_@prev }
			}
			export_trigger_value_to_variable = {
				trigger = distance
				variable = warp_distance_total
				parameters = {
					source = event_target:warp_plugin_home_base
					type = euclidean
				}
			}
			root = {
				set_variable = {
					which = warp_distance_total
					value = prev.warp_distance_total
				}
			}
			clear_variable = warp_distance_total
		}
		# compute time needed to reach destination
		fleet_get_warp_speed_mult = {
			FLEET = this
			OUTPUT = warp_speed_mult
		}
		set_variable = {
			which = warp_time_remaining
			value = value:warp_travel_time|DISTANCE|warp_distance_total|SPEED|warp_speed_mult|
		}
		clear_variable = warp_distance_total
		clear_variable = warp_speed_mult
		# make mia
		warp_plugin_initiate_return_mia = {
			TIMER_VAR = warp_time_remaining
		}
		# add additional day to allow mia to resolve
		change_variable = {
			which = warp_time_remaining
			value = 2
		}
		# set timed flag to block new mia
		set_timed_fleet_flag = {
			flag = warp_plugin_mia_in_progress
			days = warp_time_remaining
		}
		# common cleanup
		warp_plugin_warp_end_cleanup = {
			FLEET = this
		}
	}
}

## Situation: Warp in Progress
# on abort - failures
fleet_event = {
	id = warp_plugin.120
	title = warp_plugin.120.name
	desc = warp_plugin.120.desc
	picture = GFX_evt_ship_travel
	show_sound = event_ship_thrusters
	is_triggered_only = yes

	trigger = {
		fleet_has_warp_failure = yes
	}

	option = {
		name = UNFORTUNATE
		if = {
			limit = {
				has_fleet_flag = warp_plugin_weapon_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_weapon_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_propulsion_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_propulsion_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_shield_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_shield_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_armor_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_armor_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_cloak_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_cloak_failure
					months = 1
				}
			}
		}
		if = {
			limit = {
				has_fleet_flag = warp_plugin_sensor_failure
			}
			every_owned_ship = {
				add_modifier = {
					modifier = warp_plugin_sensor_failure
					months = 1
				}
			}
		}
		hidden_effect = {
			if = {
				limit = { has_fleet_flag = warp_plugin_weapon_failure }
				remove_fleet_flag = warp_plugin_weapon_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_propulsion_failure }
				remove_fleet_flag = warp_plugin_propulsion_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_shield_failure }
				remove_fleet_flag = warp_plugin_shield_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_armor_failure }
				remove_fleet_flag = warp_plugin_armor_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_cloak_failure }
				remove_fleet_flag = warp_plugin_cloak_failure
			}
			if = {
				limit = { has_fleet_flag = warp_plugin_sensor_failure }
				remove_fleet_flag = warp_plugin_sensor_failure
			}
		}
	}
}
